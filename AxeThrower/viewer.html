<!DOCTYPE html>
<html>
<head>

<script  id="vertex-shader-quad" type="x-shader/x-vertex">
    
    precision mediump float;
    attribute vec4 vertexPosition;
    
    uniform mat4 projectMat, camToWorldMat, viewProjectMat;
    uniform mat4 worldMat;
    void main() {
        

        gl_Position = viewProjectMat * worldMat * vertexPosition;
    }
</script>

<script id="fragment-shader" type="x-shader/x-fragment">

    precision mediump float;

    uniform vec4 col;
    
    void main() {
        gl_FragColor = col;
    }

</script>



<script id="vertex-phrongLighting" type="x-shader/x-vertex">

    precision mediump float;
    attribute vec4 vertexPosition;
    attribute vec3 nv;
    
    uniform mat4 worldMat, worldMatInverse, projectMat;
    
    
    // Uniform for light position for light source
    // (only one light source used here).
    uniform vec3 p0;
    
    // Uniforms for ambient, diffuse, and specular
    // components of light for light source
    uniform vec3 Ia, Id, Is;
    uniform vec3 abcDist;

    // Varying vectors for attenuateed components of light,
    // and for incident ray (i), viewing ray (view), and normal (n)
    varying vec3 Ia_pp0, Id_pp0, Is_pp0;
    varying vec3 i, view, n;
    
    uniform vec4 col;
    
    void main() {
        //gl_PointSize = 1.0;
        
        // Transform your vertices by the modelview matrix
        vec4 vertexPositionTransformed = worldMat * vertexPosition;
        gl_Position = projectMat * vertexPositionTransformed;

        

        vec4 nv4 = vec4( nv.x, nv.y, nv.z, 1.0 );
        vec4 nv4transformed = worldMatInverse * nv4;
        vec3 nvtransformed = normalize( nv4transformed.xyz );

        // Get reflection for light source
        float distance = length( p0 - vertexPositionTransformed.xyz );

        // since the distance is fairly large, the distance^2 is even larger,
        // so it is better to use the form a * distance^2 + b * distance + c
        // with small values (a = .00005, b = 0, c = 0) for the constants.

        float a = abcDist.x, b = abcDist.y, c = abcDist.z;
        float scalefactor = a * distance * distance + b * distance + c;
        Ia_pp0 = Ia / scalefactor;
        Id_pp0 = Id / scalefactor;
        Is_pp0 = Is / scalefactor;

        // Set up i, view, and n
        i = normalize( p0 - vertexPositionTransformed.xyz );
        view = normalize( p0 - vertexPositionTransformed.xyz );
        n = nvtransformed;

    }

</script>


<script id="fragment-phrongLighting" type="x-shader/x-fragment">

    precision mediump float;
    
    // Uniforms for ambient, diffuse, and specular
    // coefficients
    uniform vec3 ka, kd, ks;
    
    // Uniform for shininess
    uniform float alpha;
    
    // Varying vectors for attenuated components of light,
    // and for incident ray (i), viewing ray (view), and normal (n)    
    varying vec3 Ia_pp0, Id_pp0, Is_pp0;
    varying vec3 i, view, n;
    
    uniform vec4 col;
    
    void main() {
        vec3 Ra, Rd, Rs;
        vec3 view_renorm, i_renorm, n_renorm;
        
        // The varying vectors have been interpolated from the
        // vertex shader, but during interpolation, the values
        // at the fragments lose the normalization. So they need
        // to be re-normalized
        view_renorm = normalize( view );    
        i_renorm = normalize( i );    
        n_renorm = normalize( n );

        // Ambient reflection
        Ra.r = ka.r * Ia_pp0.r;
        Ra.g = ka.g * Ia_pp0.g;
        Ra.b = ka.b * Ia_pp0.b;
        
        // Diffuse reflection
        // costheta1 will contain dot product between incident
        // direction and transformed normal
        float costheta = dot( i_renorm, n_renorm );
        Rd.r = kd.r * Id_pp0.r * max( costheta, 0.0 );
        Rd.g = kd.g * Id_pp0.g * max( costheta, 0.0 );
        Rd.b = kd.b * Id_pp0.b * max( costheta, 0.0 );
        
        // Specular reflection
        vec3 r = 2.0*costheta*n_renorm - i_renorm;

        float cosphi = dot( r, view_renorm );
        float shine = pow( max( cosphi, 0.0 ), alpha );
        float account;
        if (costheta > 0.0){
            account = 1.0;
        } else{
            account = 0.0;
        }

        Rs.r = ks.r * Is_pp0.r * shine * account;
        Rs.g = ks.g * Is_pp0.g * shine * account;
        Rs.b = ks.b * Is_pp0.b * shine * account; 
        
        // Add all the ambient, diffuse, and specular reflections from all the light sources together
        vec3 R = clamp( Ra + Rd + Rs, 0.0, 1.0 );

        gl_FragColor = vec4( col.r*R.r, col.g*R.g, col.b*R.b, 1.0 );
    }

</script>

<script id="vertex-lighting" type="x-shader/x-vertex">

    precision mediump float;
    
    attribute vec4 vertexPosition;
    attribute vec3 nv;
    
    uniform mat4 worldMat, worldMatInverse, projectMat, worldMatTransposeInverse;
    
    varying vec3 v_normal;
    varying vec3 fragPos;
    
    void main() {

        vec4 vertexPositionTransformed = worldMat * vertexPosition;
        fragPos = (worldMat * vertexPosition).xyz;
        gl_Position = projectMat * vertexPositionTransformed;

        vec4 tempNV = vec4( nv.x, nv.y, nv.z, 1.0 );
        tempNV = worldMatTransposeInverse * tempNV;
        v_normal = tempNV.xyz;

    }

</script>


<script id="fragment-lighting" type="x-shader/x-fragment">

    precision mediump float;
    
    varying vec3 v_normal;

    struct BaseLight{
        vec3 ambient;
        vec3 diffuse;
        vec3 specular;
        bool isOn;
    };

    struct DirectionalLight{
        vec3 lightDirection;
        float lightStrength;
        BaseLight base;
    };

    uniform DirectionalLight dirLights[5];
    uniform int gNumDirLight;

    struct PointLight{
        BaseLight base;
        vec3 pos;
        float constant;
        float linear;
        float quadratic;
    };

    uniform PointLight pointLights[10];
    uniform int gNumPointLight;

    struct Material {
        vec3 ambient;
        vec3 diffuse;
        vec3 specular;
        float shininess;
    };

    uniform Material material;
    uniform bool useSpec;
    uniform vec3 viewPos;
    varying vec3 fragPos;

    vec3 CalcDirLight( DirectionalLight dirLight, vec3 n ){

        vec3 ambient = dirLight.base.ambient * material.ambient;

        float diff = max( dot( n, -dirLight.lightDirection ), 0.0 );
        vec3 diffuse = dirLight.base.diffuse * diff * material.diffuse;

        vec3 specular = vec3( 0.0 );
        if ( useSpec ){
            vec3 viewDir = normalize( viewPos - fragPos );
            vec3 reflectDir = reflect( dirLight.lightDirection, n );
            float spec = pow( max( dot( viewDir, reflectDir ), 0.0 ), material.shininess );
            specular = dirLight.base.specular * spec * material.specular;
        }

        return ambient + diffuse + specular;
    }
    
    vec3 CalcPointLight( PointLight light, vec3 n )
    {
        vec3 lightDir = normalize( light.pos - fragPos );
        // diffuse shading
        float diff = max( dot( n, lightDir ), 0.0 );

        // attenuation
        float distance = length( light.pos - fragPos );
        float attenuation = 1.0 / ( light.constant + light.linear * distance + light.quadratic * ( distance * distance )  + 0.00001 );    

        // combine results
        vec3 ambient  = light.base.ambient  * material.ambient;
        vec3 diffuse  = light.base.diffuse  * diff * material.diffuse;
        vec3 specular = vec3( 0.0 );

        if ( useSpec ){
            // specular shading
            vec3 viewDir = normalize( viewPos - fragPos );
            vec3 reflectDir = reflect( -lightDir, n );
            float spec = pow( max( dot( viewDir, reflectDir ), 0.0 ), material.shininess );
            specular = light.base.specular * spec * material.specular;
        }

        ambient  *= attenuation;
        diffuse  *= attenuation;
        specular *= attenuation;

        return (ambient + diffuse + specular);
    }

    void main() {

        vec3 normal = normalize(v_normal);
        vec3 total = vec3( 0.0, 0.0, 0.0 );

        for ( int i = 0; i < 5; i++ ){
            if ( i >= gNumDirLight ) break;
            if ( dirLights[i].base.isOn ) total += CalcDirLight( dirLights[i], normal );
        }

        for ( int i = 0; i < 10; i++ ){
            if ( i >= gNumPointLight ) break;
            if ( pointLights[i].base.isOn ) total += CalcPointLight( pointLights[i], normal );
        }

        gl_FragColor = vec4( total, 1.0 );
    }

</script>


<script type="text/javascript" src="../Common/webgl-utils.js"></script>
<script type="text/javascript" src="../Common/initShaders.js"></script>
<script type="text/javascript" src="../Common/MV.js"></script>
<script type="text/javascript" src="vector.js"></script>
<script type="text/javascript" src="scene.js"></script>
<script type="text/javascript" src="camera.js"></script>
<script type="text/javascript" src="gameObject.js"></script>
<script type="text/javascript" src="quaternion.js"></script>
<script type="text/javascript" src="matrix.js"></script>
<script type="text/javascript" src="game.js"></script>
<script type="text/javascript" src="lights.js"></script>
<script type="text/javascript" src="Objects/chair.js"></script>
<script type="text/javascript" src="Materials/chairMaterial.js"></script>
<script type="text/javascript" src="Materials/floorMaterial.js"></script>
<script type="text/javascript" src="Materials/testDirLightMat.js"></script>
</head>

<body onload = "init()">
    <canvas id="gl-canvas" height="450" width="800"> <!-- I really want this to be 900, 1600 though -->
    </canvas>
</body>
</html>
